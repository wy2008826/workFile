<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport">
	<meta content="yes" name="apple-mobile-web-app-capable">
	<meta content="black" name="apple-mobile-web-app-status-bar-style">
	<meta content="telephone=no" name="format-detection">
	<meta content="email=no" name="format-detection">
	<title>自定义缓冲滚动</title>

	<style>
		*{padding:0;margin:0;}
		body{background-color: #f8f8f8;min-height: 500px;padding-bottom: 300px;}
		#scrollWraper{width: 80%;margin:10px auto;border:1px solid #ccc;overflow: hidden;height: 300px;background-color: #fff;}
		#scrollContent  li{line-height: 40px;text-align: center;border-top: 1px solid #f2f2f2;background-color: #fff;}
		dl{padding:10px;}
		dl dt{line-height: 30px;color:#f93;}
		dl dd{line-height: 20px;color:#666;font-size: 14px;}
	</style>
</head>
<body>
	<dl>
		<dt>实现功能</dt>
		<dd>1.滚动条</dd>
		<dd>2.上拉刷新</dd>
		<dd>3.下拉加载</dd>
		<dd>4.区块滚动 snap</dd>
		<dd>5.轮播图</dd>
		<dd>6.接口化，插件化，模块化</dd>
	</dl>
	<dl>
		<dt>技术难点</dt>
		<dd>1.缓冲运动</dd>
		<dd>2.边界问题</dd>
		<dd>3.刷新</dd>
		<dd>4.加载</dd>
		<dd>5.速度计算</dd>
		<dd>6.缓冲目标位就算</dd>
		<dd>7.动画结束回调</dd>
	</dl>
	<dl>
		<dt>注意</dt>
		<dd>1.可以模仿bscroller去做一些适配和兼容性</dd>
	</dl>
	<div id="scrollWraper">
		<ul id="scrollContent">
			<li>1</li>
			<li>2</li>
			<li>3</li>
			<li>4</li>
			<li>5</li>
			<li>6</li>
			<li>7</li>
			<li>8</li>
			<li>9</li>
			<li>10</li>
			<li>11</li>
			<li>12</li>
			<li>13</li>
			<li>14</li>
			<li>15</li>
			<li>16</li>
			<li>17</li>
			<li>18</li>
			<li>19</li>
			<li>20</li>
			<li>21</li>
			<li>22</li>
			<li>23</li>
			<li>24</li>
			<li>25</li>
			<li>26</li>
			<li>27</li>
			<li>28</li>
			<li>29</li>
			<li>30</li>
		</ul>
	</div>


	<script>

		function extend(target,src){//对象扩展
			for(key in src){
				target[key]=src[key];
			}
		};

		var vendor = (function() {//浏览器供应商 获取浏览器前缀

			var elementStyle=document.createElement("div").style;
			var transformNames = {
			   webkit: 'webkitTransform',
			   Moz: 'MozTransform',
			   O: 'OTransform',
			   ms: 'msTransform',
			   standard: 'transform'
			};

			for (var key in transformNames) {
			   if (elementStyle[transformNames[key]] !== undefined) {
			      return key;
			   }
			}

			return false;
		})();

		var prefixStyle=function(style){//获取兼容各浏览器前缀样式
			if(vendor==false){
				return false;
			}
			if(vendor=="standard"){
				return style;
			}
			else{
				return vendor+style.charAt(0).toUpperCase()+style.substr(1);
			}
		};


		function WYscroller(el,options){
			this.options={
				startX:0,
				startY:0,
				scrollY: true,//滚动方向
				snap:false,//是否分隔
			};
			extend(this.options,options);
			this.wraper=typeof el=="string"?document.queryselector(el):el;//外层元素
			this.inner=this.wraper.children[0];//包含的滚动元素

			this.direction=!this.options.scrollY?"x":"y";

			this.init();//初始化
			console.log(this.options);
		}

		WYscroller.prototype={ 
			init:function(){
				var self=this;
				if(self.options.snap==false){
					self.initScroll();
					
				}
				else{

				}
			},
			initScroll:function(){
				var self=this;
				var startX=self.options.startX+"px";
				var startY=self.options.startY+"px";

				//过渡函数 过渡时间 过渡终点位置
				
				self.inner.style[prefixStyle("transitionTimingFunction")]="cubic-bezier(.35,.58,.27,.88)";
				self.inner.style[prefixStyle("transitionDuration")]="0ms";
				self.setTransform({x:self.options.startX,y:self.options.startY});

				self.wraper.addEventListener("touchstart",self.startHandler.bind(self));
				self.wraper.addEventListener("touchmove",self.moveHandler.bind(self));
				self.wraper.addEventListener("touchend",self.endHandler.bind(self));

			},
			startHandler:function(e){
				e.preventDefault();
				var self=this;
				var touch=e.touches[0];

				var start_x=self.start_x=touch.clientX;
				var start_y=self.start_y=touch.clientY;

				console.log(touch,start_x,start_y,self);
			},
			moveHandler:function(e){
				e.preventDefault();
				var self=this;
				var touch=e.touches[0];
				var move_x=self.move_x=touch.clientX;
				var move_y=self.move_y=touch.clientY;

				var dis_x=self.move_x-self.start_x;
				var dis_y=self.move_y-self.start_y;
				
				self.setTransform({x:dis_x,y:dis_y});
				console.log(touch);
			},
			endHandler:function(e){
				e.preventDefault();
				var self=this;

			},
			setTransform:function(pos){
				var self=this;
				if(self.direction=="y"){
					pos.x=0;
				}
				else{
					pos.y=0;
				}
				self.inner.style[prefixStyle("transform")]="translate3d("+pos.x+"px,"+pos.y+"px,"+"0px)";
			}
		};

		var wraper=document.getElementById("scrollWraper");
		scroller=new WYscroller(wraper,{
			startY:0
		});













		//window.onload=loaded();
		function loaded(){
			var wraper=document.getElementById("scrollWraper");
			var inner=document.getElementById("scrollContent");

			wraper.addEventListener("touchstart",startHandler);
			wraper.addEventListener("touchmove",moveHandler);
			wraper.addEventListener("touchend",endHandler);

			var startPos;
			var startTranslate;
			var lastMovePos;
			var lastMoveTime;
			var speed=0;
			var resistDistance=80;

			function startHandler(e){
				var touch=e.touches[0];
				var start_x=touch.clientX;
				var start_y=touch.clientY;
				speed=0;
				startPos={x:start_x,y:start_y};
				lastMovePos=startPos;
				lastMoveTime=new Date()*1;
				
				try{
					if(slowDownTimer){
						clearInterval(slowDownTimer);
					}
					if(animateTransformTimer){
						clearInterval(animateTransformTimer);
					}
				}
				catch(e){

				}
				
			}

			function moveHandler(e){
				e.preventDefault();
				var touch=e.touches[0];
				var move_x=touch.clientX;
				var move_y=touch.clientY;
				var move_time=new Date()*1;
				var dis_y=move_y-lastMovePos.y;
				var dur_time=move_time-lastMoveTime;
				var translate=getTransform(inner);
				if(translate.y>0&&translate.y<=resistDistance){//顶部露出
					var deta=(resistDistance-translate.y)/resistDistance;
					translate.y+=dis_y * deta;
				}
				// else if(translate.y<0 && (inner.offsetHeight<=wraper.offsetHeight-translate.y<=inner.offsetHeight+resistDistance) ){
				// 	var deta=(wraper.offsetHeight-translate.y-inner.offsetHeight-resistDistance)/resistDistance;
				// 	translate.y+=dis_y * deta;
				// }
				else{
					translate.y+=dis_y;
				}
				
				setTransform(inner,translate);

				lastMovePos={x:move_x,y:move_y};
				lastMoveTime=move_time;
				speed=(dis_y / dur_time).toFixed(2);
				console.log(speed,translate);
			}

			function endHandler(e){

				
				var translate=getTransform(inner);
				console.log(speed,-translate.y+wraper.clientHeight,inner.clientHeight);
				if(translate.y > 0){//顶部露出
					animateTransform(inner,{x:0,y:0,z:0})
				}
				else if(-translate.y+wraper.clientHeight>inner.clientHeight){
					console.log("bottom");
					animateTransform(inner,{x:0,y:0,z:0});
				}
				else{
					
					slowDown(inner);
				}
				
			}



			function getTransform(dom){
				var transform=dom.style.webkitTransform;
				if(transform){
					var translateArray=( transform.replace(/translate3d|\(|\)|px/g,"") ).split(",");
					return {x:parseFloat(translateArray[0]),y:parseFloat(translateArray[1]),z:parseFloat(translateArray[2])};
				}
				else{
					dom.style.webkitTransform="translate3d(0,0,0)";
					return {x:0,y:0,z:0}
				}
				
			}

			function setTransform(dom,translate){
				var tranStr="translate3d("+translate.x+"px,"+translate.y+"px,"+translate.z+"px)";
				
				dom.style.webkitTransform=tranStr;
			}

			function slowDown(dom){
				
				
				var intervalDur=5;
				slowDownTimer=setInterval(slow,intervalDur);
				
				function slow(){
					var deta=0.95;
					speed=speed * deta;
					var translate=getTransform(dom);
					var dis_y=speed * intervalDur * deta;
					// console.log(speed,dis_y);
					if(Math.abs(dis_y)<=0.00001){//速度足够小  终止运动
						clearInterval(slowDownTimer);
					}
					else{

						if(translate.y>0){
							var deta=(resistDistance-translate.y)/resistDistance;
							translate.y+=dis_y * deta;
							// console.log(dis_y,translate);
						}
						else{
							translate.y+=dis_y;
							// console.log("slow",dis_y,translate);

						}
						
						setTransform(dom,translate)
					}
				}
			}


			function animateTransform(dom,translateEnd){
				

				animateTransformTimer=setInterval(animate,5);

				function animate(){
					var translate=getTransform(dom);
					var dis=translateEnd.y-translate.y;

					var speed=dis * 0.03;
					if(translate.y>=0.4){
						translate.y+=speed;
						setTransform(dom,translate);
					}
					else{
						clearInterval(animateTransformTimer);
					}
					
				}
			}
		}

		

	</script>
</body>
</html>